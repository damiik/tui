--- file: src/app.rs ---
```rust
use crate::command::Command;
use crate::config::Config;
use crate::event::Event;
use crate::mcp::{McpClient, McpClientEvent};
use crate::mode::Mode;
use crate::state::{Buffer, OutputLog};
use anyhow::Result;
use crossterm::event::{KeyCode, KeyModifiers};
use tokio::sync::mpsc;

/// Immutable application state with functional transitions
#[derive(Debug)]
pub struct App {
    mode: Mode,
    output: OutputLog,
    input_buffer: Buffer,
    command_buffer: Buffer,
    status: String,
    quit: bool,
    mcp_client: McpClient,
    pub mcp_event_rx: mpsc::Receiver<McpClientEvent>,
    config: Config,
}

impl App {
    pub fn new(config: Config) -> Self {
        let (mcp_event_tx, mcp_event_rx) = mpsc::channel(100);
        let mcp_client = McpClient::new(mcp_event_tx);

        Self {
            mode: Mode::Normal,
            output: OutputLog::new()
                .with_message("MCP Client initialized. Press 'i' for INSERT mode.".to_string()),
            input_buffer: Buffer::new(),
            command_buffer: Buffer::new(),
            status: "Ready".into(),
            quit: false,
            mcp_client,
            mcp_event_rx,
            config,
        }
    }

    pub const fn mode(&self) -> Mode {
        self.mode
    }

    pub fn output(&self) -> &[String] {
        self.output.lines()
    }

    pub fn input_buffer(&self) -> &str {
        self.input_buffer.content()
    }

    pub fn command_buffer(&self) -> &str {
        self.command_buffer.content()
    }

    pub fn cursor_pos(&self) -> usize {
        match self.mode {
            Mode::Insert => self.input_buffer.cursor(),
            Mode::Command => self.command_buffer.cursor(),
            Mode::Normal => 0,
        }
    }

    pub fn status(&self) -> &str {
        &self.status
    }

    pub const fn should_quit(&self) -> bool {
        self.quit
    }

    pub async fn handle_event(mut self, event: Event) -> Result<Self> {
        match event {
            Event::Key(key) => self.handle_key(key.code, key.modifiers).await,
            Event::Tick => {
                if let Ok(mcp_event) = self.mcp_event_rx.try_recv() {
                    self.handle_mcp_event(mcp_event).await
                } else {
                    Ok(self)
                }
            }
        }
    }

    async fn handle_mcp_event(mut self, event: McpClientEvent) -> Result<Self> {
        match event {
            McpClientEvent::Connected => {
                self.status = "MCP client connected".into();
            }
            McpClientEvent::Disconnected => {
                self.status = "MCP client disconnected".into();
            }
            McpClientEvent::Message(msg) => {
                self.output = self.output.with_message(format!("[MCP] {}", msg));
            }
            McpClientEvent::Error(err) => {
                self.output = self.output.with_message(format!("[MCP Error] {}", err));
            }
            McpClientEvent::ToolsListed(tools) => {
                self.output = self.output.with_message("Available tools:".to_string());
                for tool in tools {
                    self.output = self.output.with_message(format!("  - {}", tool));
                }
            }
        }
        Ok(self)
    }

    async fn handle_key(self, code: KeyCode, mods: KeyModifiers) -> Result<Self> {
        if mods.contains(KeyModifiers::CONTROL) {
            return self.handle_ctrl_key(code).await;
        }

        match self.mode {
            Mode::Normal => self.handle_normal_key(code).await,
            Mode::Insert => self.handle_insert_key(code).await,
            Mode::Command => self.handle_command_key(code).await,
        }
    }

    async fn handle_normal_key(mut self, code: KeyCode) -> Result<Self> {
        match code {
            KeyCode::Char('i') => {
                self.mode = Mode::Insert;
                self.status = "Entered INSERT mode".into();
            }
            KeyCode::Char(':') => {
                self.mode = Mode::Command;
                self.command_buffer = Buffer::new();
                self.status = "Entered COMMAND mode".into();
            }
            KeyCode::Char('q') => {
                self.quit = true;
            }
            _ => {}
        }
        Ok(self)
    }

    async fn handle_insert_key(mut self, code: KeyCode) -> Result<Self> {
        match code {
            KeyCode::Esc => {
                self.mode = Mode::Normal;
                self.status = "Exited to NORMAL mode".into();
            }
            KeyCode::Enter => {
                let input = self.input_buffer.content().to_string();
                if !input.is_empty() {
                    self.output = self
                        .output
                        .with_message(format!("→ {}", input))
                        .with_message(format!("← Echo: {}", input));
                    self.input_buffer = Buffer::new();
                    self.status = format!("Sent: {}", input);
                }
            }
            KeyCode::Char(c) => {
                self.input_buffer = self.input_buffer.insert_char(c);
            }
            KeyCode::Backspace => {
                self.input_buffer = self.input_buffer.delete_char();
            }
            KeyCode::Left => {
                self.input_buffer = self.input_buffer.move_left();
            }
            KeyCode::Right => {
                self.input_buffer = self.input_buffer.move_right();
            }
            KeyCode::Home => {
                self.input_buffer = self.input_buffer.move_start();
            }
            KeyCode::End => {
                self.input_buffer = self.input_buffer.move_end();
            }
            _ => {}
        }
        Ok(self)
    }

    async fn handle_command_key(mut self, code: KeyCode) -> Result<Self> {
        match code {
            KeyCode::Esc => {
                self.mode = Mode::Normal;
                self.command_buffer = Buffer::new();
                self.status = "Command cancelled".into();
                Ok(self)
            }
            KeyCode::Enter => {
                let cmd_text = self.command_buffer.content().to_string();
                let mut app = self.execute_command(&cmd_text).await?;
                app.mode = Mode::Normal;
                app.command_buffer = Buffer::new();
                Ok(app)
            }
            KeyCode::Char(c) => {
                self.command_buffer = self.command_buffer.insert_char(c);
                Ok(self)
            }
            KeyCode::Backspace => {
                self.command_buffer = self.command_buffer.delete_char();
                Ok(self)
            }
            _ => Ok(self),
        }
    }

    async fn handle_ctrl_key(mut self, code: KeyCode) -> Result<Self> {
        match code {
            KeyCode::Char('q') => {
                self.quit = true;
            }
            KeyCode::Char('w') if self.mode == Mode::Insert => {
                self.input_buffer = Buffer::new();
                self.status = "Input cleared".into();
            }
            KeyCode::Char('l') => {
                self.output = OutputLog::new();
                self.status = "Output cleared".into();
            }
            _ => {}
        }
        Ok(self)
    }

    async fn execute_command(mut self, text: &str) -> Result<Self> {
        match Command::parse(text) {
            Ok(Command::Quit) => {
                self.quit = true;
                self.status = "Quitting...".into();
            }
            Ok(Command::Clear) => {
                self.output = OutputLog::new();
                self.status = "Output cleared".into();
            }
            Ok(Command::Echo(msg)) => {
                self.output = self.output.with_message(msg.clone());
                self.status = format!("Echoed: {}", msg);
            }
            Ok(Command::Help) => {
                self.output = self.output
                    .with_message("Available commands:".to_string())
                    .with_message("  :q, :quit                - Exit application".to_string())
                    .with_message("  :clear                   - Clear output".to_string())
                    .with_message("  :echo <text>             - Echo text to output".to_string())
                    .with_message("  :mcp list                - List configured MCP servers".to_string())
                    .with_message("  :mcp tools               - List tools of connected MCP server".to_string())
                    .with_message("  :mcp cn, :mcp connect    - Connect to MCP server".to_string())
                    .with_message("  :h, :help                - Show this help".to_string());
                self.status = "Help displayed".into();
            }
            Ok(Command::McpConnect(server_name)) => {
                if let Some(name) = server_name {
                    if let Some(server) = self.config.mcp_servers.iter().find(|s| s.name == name) {
                        self.status = format!("Connecting to {}...", server.url);
                        self.mcp_client.connect(server.url.clone(), server.name.clone()).await;
                    } else {
                        self.status = format!("Server '{}' not found in config.json", name);
                    }
                } else {
                    self.output = self.output.with_message("Available MCP servers:".to_string());
                    for (i, server) in self.config.mcp_servers.iter().enumerate() {
                        self.output = self.output.with_message(format!("  [{}] {}: {}", i + 1, server.name, server.url));
                    }
                    self.output = self.output.with_message("Usage: :mcp connect [server_name|server_number]".to_string());
                }
            }
            Ok(Command::McpList) => {
                self.output = self.output.with_message("Configured MCP servers:".to_string());
                for server in &self.config.mcp_servers {
                    self.output = self
                        .output
                        .with_message(format!("  - {}: {}", server.name, server.url));
                }
            }
            Ok(Command::McpTools) => {
                self.status = "Listing tools...".to_string();
                self.mcp_client.list_tools().await;
            }
            Err(e) => {
                self.status = format!("Error: {}", e);
            }
        }
        Ok(self)
    }
}

impl Default for App {
    fn default() -> Self {
        let config = Config::from_file("config.json").unwrap();
        Self::new(config)
    }
}
```

--- file: src/command.rs ---
```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum CommandError {
    #[error("Unknown command: {0}")]
    Unknown(String),
    #[error("Invalid syntax: {0}")]
    InvalidSyntax(String),
    #[error("Empty command")]
    Empty,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Command {
    Quit,
    Clear,
    Echo(String),
    Help,
    McpConnect(Option<String>),
    McpList,
    McpTools,
}

impl Command {
    /// Pure parser: &str → Result<Command, CommandError>
    /// Functional transformation with explicit error handling
    pub fn parse(input: &str) -> Result<Self, CommandError> {
        let trimmed = input.trim();

        if trimmed.is_empty() {
            return Err(CommandError::Empty);
        }

        let parts: Vec<&str> = trimmed.split_whitespace().collect();

        match parts.as_slice() {
            ["q"] | ["quit"] => Ok(Command::Quit),
            ["clear"] => Ok(Command::Clear),
            ["h"] | ["help"] => Ok(Command::Help),
            ["echo", rest @ ..] => {
                if rest.is_empty() {
                    Err(CommandError::InvalidSyntax(
                        "echo requires an argument".into(),
                    ))
                } else {
                    Ok(Command::Echo(rest.join(" ")))
                }
            }
            ["mcp", "cn"] | ["mcp", "connect"] => Ok(Command::McpConnect(None)),
            ["mcp", "cn", name] | ["mcp", "connect", name] => {
                Ok(Command::McpConnect(Some(name.to_string())))
            }
            ["mcp", "list"] => Ok(Command::McpList),
            ["mcp", "tools"] => Ok(Command::McpTools),
            [cmd, ..] => Err(CommandError::Unknown(cmd.to_string())),
            [] => unreachable!(), // Already handled empty case
        }
    }
}

// ═══════════════════════════════════════════════════════════════
// Tests: Property-based validation
// ═══════════════════════════════════════════════════════════════

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_quit_commands() {
        assert_eq!(Command::parse("q"), Ok(Command::Quit));
        assert_eq!(Command::parse("quit"), Ok(Command::Quit));
        assert_eq!(Command::parse("  q  "), Ok(Command::Quit));
    }

    #[test]
    fn test_clear_command() {
        assert_eq!(Command::parse("clear"), Ok(Command::Clear));
    }

    #[test]
    fn test_echo_command() {
        assert_eq!(
            Command::parse("echo hello world"),
            Ok(Command::Echo("hello world".into()))
        );
        assert_eq!(
            Command::parse("echo    multiple   spaces"),
            Ok(Command::Echo("multiple   spaces".into()))
        );
    }

    #[test]
    fn test_echo_without_args() {
        assert!(matches!(
            Command::parse("echo"),
            Err(CommandError::InvalidSyntax(_))
        ));
    }

    #[test]
    fn test_unknown_command() {
        assert!(matches!(
            Command::parse("unknown"),
            Err(CommandError::Unknown(_))
        ));
    }

    #[test]
    fn test_empty_command() {
        assert!(matches!(Command::parse(""), Err(CommandError::Empty)));
        assert!(matches!(Command::parse("   "), Err(CommandError::Empty)));
    }

    #[test]
    fn test_help_command() {
        assert_eq!(Command::parse("help"), Ok(Command::Help));
        assert_eq!(Command::parse("h"), Ok(Command::Help));
    }

    #[test]
    fn test_mcp_connect_command() {
        assert_eq!(
            Command::parse("mcp connect pcbvi-mcp-server"),
            Ok(Command::McpConnect(Some("pcbvi-mcp-server".into())))
        );
        assert_eq!(
            Command::parse("mcp cn pcbvi-mcp-server"),
            Ok(Command::McpConnect(Some("pcbvi-mcp-server".into())))
        );
        assert_eq!(
            Command::parse("mcp connect"),
            Ok(Command::McpConnect(None))
        );
        assert_eq!(Command::parse("mcp cn"), Ok(Command::McpConnect(None)));
    }

    #[test]
    fn test_mcp_list_command() {
        assert_eq!(Command::parse("mcp list"), Ok(Command::McpList));
    }

    #[test]
    fn test_mcp_tools_command() {
        assert_eq!(Command::parse("mcp tools"), Ok(Command::McpTools));
    }
}
```

--- file: src/config.rs ---
```rust
use serde::Deserialize;
use std::fs;

#[derive(Debug, Deserialize, Clone)]
pub struct McpServerConfig {
    pub name: String,
    pub url: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct Config {
    pub mcp_servers: Vec<McpServerConfig>,
}

impl Config {
    pub fn from_file(path: &str) -> Result<Self, anyhow::Error> {
        let content = fs::read_to_string(path)?;
        let config: Config = serde_json::from_str(&content)?;
        Ok(config)
    }
}
```

--- file: src/event.rs ---
```rust
use anyhow::Result;
use crossterm::event::{self, KeyEvent};
use std::time::Duration;

/// Event stream abstraction
#[derive(Debug, Clone, Copy)]
pub enum Event {
    Key(KeyEvent),
    Tick,
}

/// Event loop with configurable tick rate
pub struct EventLoop {
    tick_rate: Duration,
}

impl EventLoop {
    pub fn new() -> Self {
        Self {
            tick_rate: Duration::from_millis(100),
        }
    }

    pub fn with_tick_rate(mut self, rate: Duration) -> Self {
        self.tick_rate = rate;
        self
    }

    /// Pure function: Self → Result<Option<Event>>
    /// Polls for events with timeout
    pub fn next(&mut self) -> Result<Option<Event>> {
        if event::poll(self.tick_rate)? {
            match event::read()? {
                event::Event::Key(key) => Ok(Some(Event::Key(key))),
                event::Event::Resize(_, _) => Ok(Some(Event::Tick)),
                _ => Ok(None),
            }
        } else {
            Ok(Some(Event::Tick))
        }
    }
}

impl Default for EventLoop {
    fn default() -> Self {
        Self::new()
    }
}
```

--- file: src/lib.rs ---
```rust
pub mod config;
pub mod mcp;
pub mod app;
pub mod command;
pub mod event;
pub mod mode;
pub mod state;
pub mod ui;
```

--- file: src/main.rs ---
```rust
use anyhow::Result;
use crossterm::{
    event::{DisableMouseCapture, EnableMouseCapture},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use mcp_client::{app::App, config::Config, event::EventLoop, ui::UI};
use ratatui::{backend::CrosstermBackend, Terminal};
use std::io;

#[tokio::main]
async fn main() -> Result<()> {
    // Setup terminal
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    // Load config
    let config = Config::from_file("config.json")?;

    // Run app
    let app = App::new(config);
    let mut event_loop = EventLoop::new();
    let ui = UI::new();

    let res = run_loop(&mut terminal, app, &mut event_loop, &ui).await;

    // Restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    res
}
async fn run_loop(
    terminal: &mut Terminal<CrosstermBackend<io::Stdout>>,
    mut app: App,
    event_loop: &mut EventLoop,
    ui: &UI,
) -> Result<()> {
    loop {
        terminal.draw(|frame| ui.render(frame, &app))?;

        if let Some(event) = event_loop.next()? {
            app = app.handle_event(event).await?;

            if app.should_quit() {
                break;
            }
        }
    }

    Ok(())
}
```

--- file: src/mcp.rs ---
```rust
use futures_util::StreamExt;
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tokio::sync::mpsc;

#[derive(Debug, Clone)]
pub enum McpClientEvent {
    Connected,
    Disconnected,
    Message(String),
    Error(String),
    ToolsListed(Vec<String>),
}

#[derive(Debug)]
pub struct McpClient {
    event_tx: mpsc::Sender<McpClientEvent>,
    client: Client,
    url: Option<String>,
}

impl McpClient {
    pub fn new(event_tx: mpsc::Sender<McpClientEvent>) -> Self {
        Self { event_tx, client: Client::new(), url: None }
    }

    pub async fn connect(&mut self, url: String, _server_name: String) {
        self.url = Some(url.clone());
        let event_tx = self.event_tx.clone();
        let client = self.client.clone();

        tokio::spawn(async move {
            match client.get(&url).send().await {
                Ok(response) => {
                    if !response.status().is_success() {
                        let _ = event_tx
                            .send(McpClientEvent::Error(format!(
                                "Failed to connect: {}",
                                response.status()
                            )))
                            .await;
                        return;
                    }

                    let _ = event_tx.send(McpClientEvent::Connected).await;

                    let mut stream = response.bytes_stream();

                    while let Some(item) = stream.next().await {
                        match item {
                            Ok(bytes) => {
                                let msg = String::from_utf8_lossy(&bytes).to_string();
                                if let Ok(McpResponse::Success { result }) = ops::deserialize_response(&msg) {
                                    if let Ok(tools) = serde_json::from_value(result.clone()) {
                                        let _ = event_tx.send(McpClientEvent::ToolsListed(tools)).await;
                                    } else {
                                        let _ = event_tx.send(McpClientEvent::Message(serde_json::to_string_pretty(&result).unwrap_or(msg))).await;
                                    }
                                } else {
                                    let _ = event_tx.send(McpClientEvent::Message(msg)).await;
                                }
                            }
                            Err(e) => {
                                let _ = event_tx
                                    .send(McpClientEvent::Error(format!("Stream error: {}", e)))
                                    .await;
                                break;
                            }
                        }
                    }
                    let _ = event_tx.send(McpClientEvent::Disconnected).await;
                }
                Err(e) => {
                    let _ = event_tx
                        .send(McpClientEvent::Error(format!("Connection error: {}", e)))
                        .await;
                }
            }
        });
    }

    pub async fn list_tools(&self) {
        if let Some(url) = &self.url {
            let list_tools_req = ops::create_list_tools_request();
            let req_body = ops::serialize_request(&list_tools_req).unwrap();
            let client = self.client.clone();
            let url_clone = url.clone();
            let event_tx = self.event_tx.clone();

            tokio::spawn(async move {
                match client.post(url_clone).body(req_body).send().await {
                    Ok(response) => {
                        if !response.status().is_success() {
                            let _ = event_tx
                                .send(McpClientEvent::Error(format!(
                                    "Failed to list tools: {}",
                                    response.status()
                                )))
                                .await;
                        }
                    }
                    Err(e) => {
                        let _ = event_tx
                            .send(McpClientEvent::Error(format!("Failed to list tools: {}", e)))
                            .await;
                    }
                }
            });
        }
    }
}

/// MCP Protocol Message Types
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "method", rename_all = "snake_case")]
pub enum McpRequest {
    Initialize { params: InitializeParams },
    ListTools,
    CallTool { params: CallToolParams },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InitializeParams {
    pub protocol_version: String,
    pub capabilities: HashMap<String, bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallToolParams {
    pub name: String,
    pub arguments: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpResponse {
    Success { result: serde_json::Value },
    Error { error: McpError },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpError {
    pub code: i32,
    pub message: String,
}

/// Functional composition for MCP operations
pub mod ops {
    use super::*;

    pub fn create_initialize_request(version: &str) -> McpRequest {
        McpRequest::Initialize {
            params: InitializeParams {
                protocol_version: version.to_string(),
                capabilities: HashMap::new(),
            },
        }
    }

    pub fn create_list_tools_request() -> McpRequest {
        McpRequest::ListTools
    }

    pub fn create_call_tool_request(
        name: String,
        arguments: HashMap<String, serde_json::Value>,
    ) -> McpRequest {
        McpRequest::CallTool {
            params: CallToolParams { name, arguments },
        }
    }

    pub fn serialize_request(request: &McpRequest) -> Result<String, serde_json::Error> {
        serde_json::to_string(request)
    }

    pub fn deserialize_response(data: &str) -> Result<McpResponse, serde_json::Error> {
        serde_json::from_str(data)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_serialize_initialize() {
        let req = ops::create_initialize_request("1.0");
        let serialized = ops::serialize_request(&req).unwrap();
        assert!(serialized.contains("initialize"));
    }

    #[test]
    fn test_serialize_list_tools() {
        let req = ops::create_list_tools_request();
        let serialized = ops::serialize_request(&req).unwrap();
        assert!(serialized.contains("list_tools"));
    }
}
```

--- file: src/mode.rs ---
```rust
use ratatui::style::Color;

/// Modal states inspired by Vim's philosophy
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Mode {
    Normal,
    Insert,
    Command,
}

impl Mode {
    /// Pure function: Mode → &str
    pub const fn name(&self) -> &'static str {
        match self {
            Mode::Normal => "NORMAL",
            Mode::Insert => "INSERT",
            Mode::Command => "COMMAND",
        }
    }

    /// Pure function: Mode → Color
    /// Signal: Each mode has distinct visual identity
    pub const fn color(&self) -> Color {
        match self {
            Mode::Normal => Color::Cyan,
            Mode::Insert => Color::Green,
            Mode::Command => Color::Yellow,
        }
    }

    /// Pure function: Mode → bool
    /// Determines if cursor should be visible
    pub const fn shows_cursor(&self) -> bool {
        matches!(self, Mode::Insert | Mode::Command)
    }

    /// Pure function: Mode → &str
    /// Help text for current mode
    pub const fn help_text(&self) -> &'static str {
        match self {
            Mode::Normal => "i:Insert | ::Command | ^Q:Quit",
            Mode::Insert => "ESC:Normal | ↵:Send | ^W:Clear",
            Mode::Command => "ESC:Cancel | ↵:Execute",
        }
    }
}
```

--- file: src/state.rs ---
```rust
/// Immutable text buffer with cursor position
/// Pure functional data structure
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Buffer {
    content: String,
    cursor: usize,
}

impl Buffer {
    pub fn new() -> Self {
        Self {
            content: String::new(),
            cursor: 0,
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }

    pub const fn cursor(&self) -> usize {
        self.cursor
    }

    /// Pure transformation: Buffer → char → Buffer
    pub fn insert_char(mut self, c: char) -> Self {
        self.content.insert(self.cursor, c);
        self.cursor += 1;
        self
    }

    /// Pure transformation: Buffer → Buffer
    pub fn delete_char(mut self) -> Self {
        if self.cursor > 0 && !self.content.is_empty() {
            self.content.remove(self.cursor - 1);
            self.cursor -= 1;
        }
        self
    }

    pub fn move_left(mut self) -> Self {
        self.cursor = self.cursor.saturating_sub(1);
        self
    }

    pub fn move_right(mut self) -> Self {
        if self.cursor < self.content.len() {
            self.cursor += 1;
        }
        self
    }

    pub fn move_start(mut self) -> Self {
        self.cursor = 0;
        self
    }

    pub fn move_end(mut self) -> Self {
        self.cursor = self.content.len();
        self
    }

    pub fn clear(mut self) -> Self {
        self.content.clear();
        self.cursor = 0;
        self
    }
}

impl Default for Buffer {
    fn default() -> Self {
        Self::new()
    }
}

// ═══════════════════════════════════════════════════════════════
// Output log with functional append
// ═══════════════════════════════════════════════════════════════

const MAX_LOG_LINES: usize = 1000;

/// Immutable log with bounded size
#[derive(Debug, Clone)]
pub struct OutputLog {
    lines: Vec<String>,
}

impl OutputLog {
    pub fn new() -> Self {
        Self { lines: Vec::new() }
    }

    pub fn lines(&self) -> &[String] {
        &self.lines
    }

    /// Pure transformation: OutputLog → String → OutputLog
    /// Maintains bounded size via functional composition
    pub fn with_message(mut self, msg: String) -> Self {
        self.lines.push(msg);
        
        // Maintain bound by removing oldest entries
        if self.lines.len() > MAX_LOG_LINES {
            self.lines.drain(0..(self.lines.len() - MAX_LOG_LINES));
        }
        
        self
    }

    pub fn clear(mut self) -> Self {
        self.lines.clear();
        self
    }
}

impl Default for OutputLog {
    fn default() -> Self {
        Self::new()
    }
}

// ═══════════════════════════════════════════════════════════════
// Tests
// ═══════════════════════════════════════════════════════════════

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_buffer_insert() {
        let buf = Buffer::new().insert_char('a').insert_char('b');
        assert_eq!(buf.content(), "ab");
        assert_eq!(buf.cursor(), 2);
    }

    #[test]
    fn test_buffer_delete() {
        let buf = Buffer::new()
            .insert_char('a')
            .insert_char('b')
            .delete_char();
        assert_eq!(buf.content(), "a");
        assert_eq!(buf.cursor(), 1);
    }

    #[test]
    fn test_buffer_movement() {
        let buf = Buffer::new()
            .insert_char('a')
            .insert_char('b')
            .move_left()
            .insert_char('c');
        assert_eq!(buf.content(), "acb");
        assert_eq!(buf.cursor(), 2);
    }

    #[test]
    fn test_output_log_append() {
        let log = OutputLog::new()
            .with_message("line1".into())
            .with_message("line2".into());
        assert_eq!(log.lines().len(), 2);
        assert_eq!(log.lines()[0], "line1");
        assert_eq!(log.lines()[1], "line2");
    }

    #[test]
    fn test_output_log_bounds() {
        let mut log = OutputLog::new();
        for i in 0..1500 {
            log = log.with_message(format!("line{}", i));
        }
        assert!(log.lines().len() <= MAX_LOG_LINES);
    }
}
```

--- file: src/ui.rs ---
```rust
use crate::app::App;
use crate::mode::Mode;
use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph, Scrollbar, ScrollbarOrientation, ScrollbarState, Wrap},
    Frame,
};

/// Pure UI rendering logic - no side effects
pub struct UI {
    scroll_offset: usize,
}

impl UI {
    pub const fn new() -> Self {
        Self { scroll_offset: 0 }
    }

    /// Pure function: Frame × App → ()
    /// Renders application state to terminal frame
    pub fn render(&self, frame: &mut Frame, app: &App) {
        let layout = Self::create_layout(frame.area());

        self.render_output(frame, app, layout.output);
        self.render_status_bar(frame, app, layout.status);
        self.render_input_line(frame, app, layout.input);
    }

    // ═══════════════════════════════════════════════════════════════
    // Layout composition
    // ═══════════════════════════════════════════════════════════════

    fn create_layout(area: Rect) -> LayoutAreas {
        let chunks = Layout::default()
            .direction(Direction::Vertical)
            .constraints([
                Constraint::Min(3),      // Output area
                Constraint::Length(1),   // Status bar
                Constraint::Length(1),   // Input line
            ])
            .split(area);

        LayoutAreas {
            output: chunks[0],
            status: chunks[1],
            input: chunks[2],
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Output area rendering
    // ═══════════════════════════════════════════════════════════════

    fn render_output(&self, frame: &mut Frame, app: &App, area: Rect) {
        let lines: Vec<Line> = app
            .output()
            .iter()
            .map(|s| Line::from(s.as_str()))
            .collect();

        let block = Block::default()
            .borders(Borders::ALL)
            .border_style(Style::default().fg(Color::DarkGray))
            .title(Span::styled(
                " Output ",
                Style::default()
                    .fg(Color::Cyan)
                    .add_modifier(Modifier::BOLD),
            ));

        let paragraph = Paragraph::new(lines)
            .block(block)
            .wrap(Wrap { trim: false })
            .scroll((self.scroll_offset as u16, 0));

        frame.render_widget(paragraph, area);

        // Render scrollbar if content exceeds visible area
        if app.output().len() > area.height as usize - 2 {
            let scrollbar = Scrollbar::default()
                .orientation(ScrollbarOrientation::VerticalRight)
                .begin_symbol(Some("↑"))
                .end_symbol(Some("↓"));

            let mut scrollbar_state = ScrollbarState::new(app.output().len())
                .position(self.scroll_offset);

            frame.render_stateful_widget(
                scrollbar,
                area.inner(ratatui::layout::Margin {
                    vertical: 1,
                    horizontal: 0,
                }),
                &mut scrollbar_state,
            );
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Status bar rendering - shows mode and status message
    // ═══════════════════════════════════════════════════════════════

    fn render_status_bar(&self, frame: &mut Frame, app: &App, area: Rect) {
        let mode = app.mode();

        let mode_indicator = Span::styled(
            format!(" {} ", mode.name()),
            Style::default()
                .fg(Color::Black)
                .bg(mode.color())
                .add_modifier(Modifier::BOLD),
        );

        let status_text = Span::styled(
            format!(" {} ", app.status()),
            Style::default().fg(Color::White),
        );

        let help_text = Span::styled(
            format!(" {} ", mode.help_text()),
            Style::default().fg(Color::DarkGray),
        );

        let line = Line::from(vec![mode_indicator, status_text, help_text]);

        let paragraph = Paragraph::new(line)
            .style(Style::default().bg(Color::Black));

        frame.render_widget(paragraph, area);
    }

    // ═══════════════════════════════════════════════════════════════
    // Input line rendering - shows current buffer based on mode
    // ═══════════════════════════════════════════════════════════════

    fn render_input_line(&self, frame: &mut Frame, app: &App, area: Rect) {
        let (prefix, content, cursor_offset) = match app.mode() {
            Mode::Normal => ("", "", 0),
            Mode::Insert => ("> ", app.input_buffer(), 2),
            Mode::Command => (":", app.command_buffer(), 1),
        };

        let prefix_span = Span::styled(
            prefix,
            Style::default()
                .fg(app.mode().color())
                .add_modifier(Modifier::BOLD),
        );

        let content_span = Span::raw(content);

        let line = Line::from(vec![prefix_span, content_span]);

        let paragraph = Paragraph::new(line)
            .style(Style::default().bg(Color::Black).fg(Color::White));

        frame.render_widget(paragraph, area);

        // Set cursor position if in input mode
        if app.mode().shows_cursor() {
            let cursor_x = area.x + cursor_offset + app.cursor_pos() as u16;
            let cursor_y = area.y;

            if cursor_x < area.x + area.width {
                frame.set_cursor_position((cursor_x, cursor_y));
            }
        }
    }
}

impl Default for UI {
    fn default() -> Self {
        Self::new()
    }
}

// ═══════════════════════════════════════════════════════════════
// Layout helper structure
// ═══════════════════════════════════════════════════════════════

struct LayoutAreas {
    output: Rect,
    status: Rect,
    input: Rect,
}
```

